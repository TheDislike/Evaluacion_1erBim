Universidad Técnica Particular de Loja

Estudiante: Jonathan David Guayllas Guamán

Fecha: 28/11/2025

Materia: Programación Funcional

Tema: Reflexión sobre el Sistema de Gestión de Biblioteca Digital

En base al desarrollo del sistema de gestión de biblioteca implementado en JavaScript y Scala, responde a las siguientes preguntas planteadas para el análisis crítico del paradigma funcional:

Comparación de Paradigmas: ¿Qué ventajas encontraste al usar programación funcional y qué desafíos enfrentaste al evitar la mutación?

Ventajas encontradas:

• Claridad declarativa y legibilidad:
Al desarrollar el módulo de reportes (Ejercicio 1.5), noté que el código se lee como una descripción de "qué quiero obtener" en lugar de "cómo hacerlo". El uso de cadenas de operaciones como filter, map y reduce permiten una transformación mas eficaz de los datos. Por ejemplo, en el sistema de recomendaciones, fácilmente se pudo transformar una lista de libros en un "Top 10" sin declarar una sola variable temporal, lo cual hace que el código sea más legible, efiza y corto al no tener que usar múltiples búcles.

• Reducción de efectos secundarios (Funciones Puras):
En el Ejercicio 1.3, al implementar funciones puras para calcular ciertas variables, observamos la gran ventaja de la transparencia referencial. Saber que la función calcularDiasRetraso siempre devolverá el mismo valor para las mismas fechas, sin depender de la hora del sistema o variables externas, me da una gran certeza al momento de tener que usar esa función para esos calculos. Ayudandonos a eliminar una categoría entera de "bugs" relacionados con el estado global que puede cambiar inesperadamente en sistemas imperativos grandes.

Desafíos enfrentados:

• El cambio de modelo mental (Inmutabilidad):
El mayor reto de este ejercicio fue dejar de pensar en "modificar" objetos. En el Ejercicio 1.2 con Scala, mi lógica inicial para devolver un libro era intentar hacer algo como prestamo.activo = false. Tuve que forzarme a cambiar el chip, para poder pensar en "crear una copia modificada" usando el método .copy(). Al principio, esto parecia ineficiente o redundante, pero entendí que es necesario para mantener la inmutabilidad en algunas ocasiones.

• Complejidad en acumuladores:
Usar reduce para agrupar datos (como contar libros por categoría en JS) fue cognitivamente más difícil que usar un bucle tradicional. Ya que tenia que simular como el objeto hiba acumulando, lo cual requiere una mayor abstracción que simplemente empujar elementos a un array existente.

Análisis Crítico: ¿En qué situaciones preferirías programación funcional sobre imperativa y viceversa?

Preferiría Programación Funcional cuando:

• Se trabaja con transformación de datos:
Si el objetivo sería tomar datos de una fuente, filtrarlos, transformarlos y generar un reporte (como en el Ejercicio 2.2 de composición de precios), la composición de funciones (andThen) es superior arquitecturalmente. Ya que me permite reutilizar piezas pequeñas de lógica y testearlas aisladamente.

• Sistemas con alta concurrencia:
Aunque este proyecto fue local, entiendo que en un servidor real con miles de usuarios, la inmutabilidad de Scala es vital. Si dos hilos intentan acceder al mismo objeto "Libro", en la programación imperativa podría haber condiciones de carrera. En funcional, como el objeto no cambia, es seguro leerlo desde múltiples hilos sin bloqueos (locks).

Preferiría Programación Imperativa cuando:

• El rendimiento de memoria sea crítico :
Un ejempleo seria si estuviera programando el firmware de un lector de huellas de la biblioteca con muy poca RAM, la creación constante de nuevos objetos que exige la inmutabilidad sería demasiado costosa y demandante para el recolector de basura.

• Algoritmos que dependen de la mutación de estado local:
Ciertos algoritmos complejos de grafos o de ordenamiento son mucho más naturales y eficientes si se permite la mutación controlada dentro de un ámbito local, ya que simularlos con recursión pura puede llevar a desbordamientos de pila si el lenguaje no optimiza la recursión de cola.

Comparación de Lenguajes: Diferencias entre JavaScript y Scala para programación funcional.

JavaScript:

• Es flexible pero requiere disciplina:
JS nos permite escribir funcionalmente, pero no te obliga. Las funciones de orden superior (map, filter) son nativas y fáciles de usar, especialmente con la sintaxis de flecha (=>). Sin embargo, el lenguaje es "traicionero": métodos como .sort() mutan el array original, lo cual rompe los principios funcionales si no se tiene cuidado (tuve que usar .slice()y .sort() para evitar estas mutaciones).

• Tipado dinámico:
Nos facilita el prototipado rápido (como vimos en los ejercicios de objetos literales), pero lo que se puede hacer difícil es componer funciones complejas sin cometer errores de tipo en tiempo de ejecución.

Scala:

• Robustez y diseño nativo:
Scala se sintió mucho más adecuado para este paradigma. La distinción entre val (inmutable) y var (mutable) impone las reglas más claras al momento de empezar a programar. Las case classes nos facilitan enormemente la inmutabilidad con el método copy.

• Sistema de Tipos:
En el Ejercicio 2.2 (Composición), el compilador de Scala fue de gran ayuda. Ya que si intentaba conectar una función que devolvía un Double con una que esperaba un Libro, el código no compilaba. Esto ayudaba a prevenir de errores antes de la ejecución, algo que en JS solo podia darme cuenta al momento de correr el programa. Por este motivo, Scala me pareció más adecuado para construir el núcleo robusto del sistema.

Aplicación Práctica: ¿Cómo aplicarías estos conceptos en un proyecto real?

Los conceptos dominados en esta evaluación tienen varias aplicaciones directas en la industria actual:

• Gestión de Estado en Frontend:
La lógica que usamos en el Ejercicio 1.5 para la generación de reportes es igual a cómo funcionan los "Reducers" en Redux. En una aplicación real de biblioteca construida con React, el estado de la interfaz (qué libros se muestran, si el modal de préstamo está abierto) sería inmutable. Cada interacción del usuario despacharía una acción que pasaría por una función pura para generar el nuevo estado visual, garantizando predictibilidad.

• Arquitectura de Microservicios y Serverless:
El patrón de "Estrategia" del Ejercicio 2.1 es ideal para microservicios. Podríamos tener una función AWS Lambda que actúe como procesador genérico de préstamos, y que reciba como parámetro (o inyección) la estrategia de notificación (Email, SMS, Push). Esto desacopla la lógica, permitiendo cambiar el proveedor de correos sin tocar el código del cálculo de préstamos.

• Pruebas Unitarias Automatizadas (Testing):
La mayor ganancia práctica es la "testabilidad". En un entorno de Integración Continua (CI/CD), las funciones puras como calcularMulta son triviales de probar. No necesitamos levantar una base de datos de prueba ni simular el tiempo del servidor. Esto reduce drásticamente el tiempo de ejecución de la suite de pruebas y aumenta la calidad del software entregado.